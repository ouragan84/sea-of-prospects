import {tiny, defs} from './examples/common.js';
const { vec3 } = tiny;

export class GerstnerWave{

    constructor()
    {
        this.n = 30;
		this.s = [0.1, 0.10485330470602275, 0.11381760719782011, 0.1265142307666522, 0.12927877207919886, 0.1391383270891647, 0.15174340163951358, 0.15720212447147353, 0.17739765423095497, 0.1856290320914309, 0.20461957329014113, 0.21397340481639013, 0.22261527975047152, 0.2380169048609526, 0.2717951634211129, 0.27834979534553395, 0.3005726197055354, 0.3220353773974762, 0.3431911112266567, 0.3827172581347963, 0.3878975956029178, 0.4148104810162244, 0.46922817483834556, 0.507086205852071, 0.530725985348299, 0.5625947263605202, 0.6258693662780145, 0.648272777857156, 0.6796153017671225, 0.7390884197919649];
		this.l = [20.0, 16.276587030926855, 13.793525431712741, 12.56019317604558, 9.557227149463156, 7.786937213857204, 6.812802166697542, 5.337195931277145, 5.060545911702058, 3.9576050222862946, 3.296216120112831, 2.718858712951965, 2.435098602772112, 1.9775315356895122, 1.8387550587059367, 1.5199976202358738, 1.2488054153131989, 1.0359018778695126, 0.813960243988936, 0.7582356154354, 0.5886331716119202, 0.5323029760610809, 0.422594606481265, 0.3440074371387982, 0.2828617949229588, 0.24543096659910876, 0.189058872239466, 0.16838450343154204, 0.13057375936835303, 0.11163262466859375];
		this.v = [0.5, 0.532601937212548, 0.5888412491908516, 0.6143706506709481, 0.6984642812491132, 0.7415832468106065, 0.8184624473785139, 0.8425006807453497, 0.9527690979970167, 1.0099357230962775, 1.0898581834591428, 1.165880971122125, 1.2770841397768782, 1.392802543098797, 1.5099361139985337, 1.5949370906218938, 1.6670796140138708, 1.8938622780113445, 2.039447405834382, 2.0700539818015122, 2.346134188088755, 2.542918563473768, 2.6711488080169463, 2.849977202420483, 3.0419803095622466, 3.3320087520409585, 3.8189658992204363, 4.005934903388934, 4.401437184431325, 4.793944361879538];
		this.dir = [
			vec3(0.9834054874003986, 0, 0.18142118771186763),
			vec3(0.42108777680775317, 0, 0.9070198918563496),
			vec3(0.9030196630375303, 0, -0.4295992180714314),
			vec3(0.667509063124111, 0, -0.7446016724713769),
			vec3(0.5880869968223698, 0, 0.8087976781423435),
			vec3(-0.25632455830816436, 0, 0.9665907721513404),
			vec3(0.6104374498490147, 0, 0.792064466960759),
			vec3(0.2707158371475335, 0, 0.9626593039687044),
			vec3(0.2471560123301823, 0, 0.9689756991633188),
			vec3(0.5671978274306891, 0, -0.8235815834256532),
			vec3(0.7160807068832423, 0, -0.6980174934982617),
			vec3(-0.9840239030615004, 0, -0.17803639572742058),
			vec3(-0.16941044081394216, 0, 0.9855455862329382),
			vec3(0.9316484019217747, 0, -0.3633610534944595),
			vec3(-0.6685194562678181, 0, -0.7436946527919781),
			vec3(0.8168343486940616, 0, 0.5768722967811406),
			vec3(0.23742650406139965, 0, -0.9714055050128046),
			vec3(-0.9955295940821558, 0, -0.09445013132133835),
			vec3(-0.8112177714246033, 0, 0.5847441554431305),
			vec3(-0.9797577683723648, 0, -0.20018670114171808),
			vec3(-0.6809494597584, 0, 0.7323304126244814),
			vec3(0.9464150979627536, 0, -0.3229527246334229),
			vec3(0.3299754233712256, 0, 0.9439895232315773),
			vec3(-0.14038906905008464, 0, 0.9900964141391739),
			vec3(-0.18046599166842384, 0, -0.9835812248366336),
			vec3(0.0061053322839791915, 0, 0.9999813622851689),
			vec3(0.5181603558019938, 0, -0.8552834884850468),
			vec3(0.8467115204176219, 0, 0.5320522541932127),
			vec3(0.9891724438157774, 0, -0.1467578835890014),
			vec3(0.8804761544259202, 0, 0.4740904359796168),
		];

        for (let i = 0; i < this.n; i++){
            this.dir[i] = this.dir[i].normalized();
        }
    }

    gersrnerWave(pos, t){
        let new_pos = vec3(pos[0], pos[1], pos[2]);
        
        for (let i = 0; i < this.n; i++){
            const k = 2 * Math.PI / this.l[i];
            const d = this.dir[i]
            const f = k * (pos[0] * d[0] + pos[2] * d[2]) - (this.v[i] * t);
            const a = this.s[i] / k;

            new_pos = new_pos.plus(vec3(
                d[0] * a * Math.cos(f), 
                a * Math.sin(f), 
                d[2] * a * Math.cos(f)
            ));
        }

        return new_pos;
    }

    gersrnerWaveNormal(pos, t){
        let rx = vec3(1,0,0);
        let rz = vec3(0,0,1);

        for (let i = 0; i < this.n; i++){
            const k = 2 * Math.PI / this.l[i];
            const d = this.dir[i]
            const f = k * (pos[0] * d[0] + pos[2] * d[2]) - (this.v[i] * t);
            const a = this.s[i] / k;

            rx = rx.plus(vec3(
                - d[0] * d[0] * a * k * Math.sin(f),
                d[0] * a * k * Math.cos(f),
                - d[0] * d[2] * a * k * Math.sin(f)
            ));

            rz = rz.plus(vec3(
                - d[2] * d[0] * a * k * Math.sin(f),
                d[2] * a * k * Math.cos(f),
                - d[2] * d[2] * a * k * Math.sin(f)
            ));
        }

        const n = rz.cross(rx).normalized();
        if (n[1] < 0)
            return n.times(-1);
        return n;
    }



    get_glsl_strings(){
        // Ensure all numeric values have a decimal point to be treated as floats
        let sInit = this.s.map((value, index) => `steepness[${index}] = ${value.toFixed(1)};`).join("\n    ");
        let lInit = this.l.map((value, index) => `wave_length[${index}] = ${value.toFixed(1)};`).join("\n    ");
        let vInit = this.v.map((value, index) => `speed[${index}] = ${value.toFixed(1)};`).join("\n    ");
        let dirInit = this.dir.map((vec, index) => `direction[${index}] = vec3(${vec.map(v => v.toFixed(1)).join(", ")});`).join("\n    ");
    
        return {
            n: `int num_waves = ${this.n};`,
            s: `float steepness[${this.n}];`,
            l: `float wave_length[${this.n}];`,
            v: `float speed[${this.n}];`,
            dir: `vec3 direction[${this.n}];`,
            sInit: sInit,
            lInit: lInit,
            vInit: vInit,
            dirInit: dirInit
        }
    }

    solveForY(x, z, t){
        // solve for y at a given x, z, and t.
        // first apply the gersrner wave function to the x, z, and t.
        // based on the new x, z, can compute the error and converge to the x and z value that will give the y value we want.

        let y = 0;
        let error = 0;
        let iterations = 0;
        let max_iterations = 10;

        while (error < 0.01 && iterations < max_iterations){
            let new_pos = vec3(x, y, z);
            let new_y = this.gersrnerWave(new_pos, t)[1];
            error = Math.abs(new_y - y);
            y = new_y;
            iterations++;
        }

        return y;

    }



}  